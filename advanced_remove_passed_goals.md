네, 알겠습니다. 우리가 함께 설계한 모든 강건한 로직(경로 유효성 검사, 거리 기반 동적 탐색 윈도우, 히스테리시스, 최대 경로 이탈 체크 등)을 포함하여, Nav2와 함께 사용할 수 있는 Production-ready 수준의 완벽한 커스텀 BT 노드 소스코드를 작성해 드리겠습니다.

코드는 Modern C++(17) 스타일 가이드와 ROS 2 Jazzy를 기준으로 작성되었습니다.

-----

### 1\. 헤더 파일 (`advanced_remove_passed_goals.hpp`)

이 파일은 클래스 정의, 멤버 변수, BT 포트(입출력)를 선언합니다.

```cpp
#pragma once

#include <string>
#include <vector>
#include <map>

#include "rclcpp/rclcpp.hpp"
#include "behaviortree_cpp/bt_factory.h"
#include "nav2_behavior_tree/bt_action_node.hpp"
#include "geometry_msgs/msg/pose_stamped.hpp"
#include "nav_msgs/msg/path.hpp"

namespace robust_nav2_bt_nodes
{

/**
 * @brief A BT node to remove passed goals from a list of goals based on progress along a path.
 *
 * This node implements a robust logic to determine if waypoints have been passed.
 * It operates on a dense path from a planner and uses a dynamic, distance-based
 * search window to find the robot's progress. It is resilient to path replanning,
 * large deviations from the path, and oscillations near the goal.
 */
class AdvancedRemovePassedGoals : public BT::StatefulActionNode
{
public:
  /**
   * @brief A constructor for nav2_behavior_tree::AdvancedRemovePassedGoals
   * @param xml_tag_name Name for the XML tag for this node
   * @param conf BT node configuration
   */
  AdvancedRemovePassedGoals(
    const std::string & xml_tag_name,
    const BT::NodeConfiguration & conf);

  /**
   * @brief Creates list of BT ports
   * @return BT::PortsList Containing basic ports along with node-specific ports
   */
  static BT::PortsList providedPorts();

protected:
  /**
   * @brief The main execution routine.
   * @return BT::NodeStatus Status of tick execution
   */
  BT::NodeStatus onRunning() override;

  /**
   * @brief The routine called when the node is ticked for the first time.
   * @return BT::NodeStatus Status of the node after initialization
   */
  BT::NodeStatus onStart() override;

  /**
   * @brief The routine called when the node is halted.
   */
  void onHalted() override;

private:
  // ROS-related members
  rclcpp::Node::SharedPtr node_;
  rclcpp::Clock::SharedPtr clock_;
  rclcpp::Logger logger_;
  std::shared_ptr<tf2_ros::Buffer> tf_;

  // Parameters from BT XML
  double search_radius_;
  unsigned int hysteresis_indices_;
  double max_path_deviation_;
  std::string global_frame_;
  std::string robot_base_frame_;
  rclcpp::Duration transform_tolerance_;

  // Node state variables
  size_t last_path_hash_;
  std::map<size_t, size_t> waypoint_to_path_index_map_;
  size_t last_progress_index_;
  std::vector<geometry_msgs::msg::PoseStamped> initial_goals_;

  // Helper methods
  bool updateRobotPose(geometry_msgs::msg::PoseStamped & robot_pose);
  bool isPathUpdated(const nav_msgs::msg::Path & path);
  void createWaypointIndexMapping(
    const nav_msgs::msg::Path & path,
    const std::vector<geometry_msgs::msg::PoseStamped> & goals);
  size_t findCurrentProgressIndex(
    const nav_msgs::msg::Path & path,
    const geometry_msgs::msg::PoseStamped & robot_pose);
};

}  // namespace robust_nav2_bt_nodes
```

-----

### 2\. 소스 파일 (`advanced_remove_passed_goals.cpp`)

이 파일에 우리가 설계한 모든 핵심 로직이 구현됩니다.

```cpp
#include "path/to/your/header/advanced_remove_passed_goals.hpp"

#include <functional>
#include <numeric>

#include "nav2_util/robot_utils.hpp"
#include "nav2_util/geometry_utils.hpp"
#include "tf2_geometry_msgs/tf2_geometry_msgs.hpp"

namespace robust_nav2_bt_nodes
{

// Helper function to calculate distance between two poses (2D)
inline double euclidean_distance(
  const geometry_msgs::msg::Pose & p1,
  const geometry_msgs::msg::Pose & p2)
{
  return std::hypot(p1.position.x - p2.position.x, p1.position.y - p2.position.y);
}

AdvancedRemovePassedGoals::AdvancedRemovePassedGoals(
  const std::string & xml_tag_name,
  const BT::NodeConfiguration & conf)
: BT::StatefulActionNode(xml_tag_name, conf)
{
  node_ = config().blackboard->get<rclcpp::Node::SharedPtr>("node");
  tf_ = config().blackboard->get<std::shared_ptr<tf2_ros::Buffer>>("tf_buffer");
  clock_ = node_->get_clock();
  logger_ = node_->get_logger();

  getInput("search_radius", search_radius_);
  int hysteresis_int;
  getInput("hysteresis_indices", hysteresis_int);
  hysteresis_indices_ = static_cast<unsigned int>(hysteresis_int);
  getInput("max_path_deviation", max_path_deviation_);
  getInput("global_frame", global_frame_);
  getInput("robot_base_frame", robot_base_frame_);
  double transform_tolerance_secs;
  getInput("transform_tolerance", transform_tolerance_secs);
  transform_tolerance_ = rclcpp::Duration::from_seconds(transform_tolerance_secs);
}

BT::PortsList AdvancedRemovePassedGoals::providedPorts()
{
  return {
    BT::InputPort<std::vector<geometry_msgs::msg::PoseStamped>>("input_goals", "Original list of goals"),
    BT::InputPort<nav_msgs::msg::Path>("input_path", "The path generated by the planner"),
    BT::OutputPort<std::vector<geometry_msgs::msg::PoseStamped>>("output_goals", "Filtered list of goals with passed ones removed"),
    BT::InputPort<double>("search_radius", 2.0, "Physical distance (m) to define the search window for robot's progress"),
    BT::InputPort<int>("hysteresis_indices", 5, "Number of indices past the target index to confirm a goal is passed"),
    BT::InputPort<double>("max_path_deviation", 1.5, "Max distance (m) the robot can be from the path before failing"),
    BT::InputPort<std::string>("global_frame", "map", "Global frame for TF"),
    BT::InputPort<std::string>("robot_base_frame", "base_link", "Robot base frame for TF"),
    BT::InputPort<double>("transform_tolerance", 0.1, "Transform tolerance in seconds")
  };
}

BT::NodeStatus AdvancedRemovePassedGoals::onStart()
{
  RCLCPP_DEBUG(logger_, "AdvancedRemovePassedGoals: onStart");

  // Reset all state variables when the node is started
  last_path_hash_ = 0;
  waypoint_to_path_index_map_.clear();
  last_progress_index_ = 0;
  if (!getInput("input_goals", initial_goals_)) {
    RCLCPP_WARN(logger_, "input_goals not provided, cannot initialize.");
    return BT::NodeStatus::FAILURE;
  }

  return BT::NodeStatus::RUNNING;
}

void AdvancedRemovePassedGoals::onHalted()
{
  RCLCPP_DEBUG(logger_, "AdvancedRemovePassedGoals: onHalted");
}

BT::NodeStatus AdvancedRemovePassedGoals::onRunning()
{
  // 1. Get inputs from blackboard
  std::vector<geometry_msgs::msg::PoseStamped> current_goals;
  nav_msgs::msg::Path path;

  if (!getInput("input_goals", current_goals) || !getInput("input_path", path)) {
    RCLCPP_WARN(logger_, "input_goals or input_path not available on the blackboard.");
    return BT::NodeStatus::FAILURE;
  }

  // 2. Defensive checks
  if (current_goals.empty()) {
    setOutput("output_goals", current_goals);
    return BT::NodeStatus::SUCCESS;
  }
  if (path.poses.size() < 2) {
    RCLCPP_WARN(logger_, "Path is too short to process. Passing goals through.");
    setOutput("output_goals", current_goals);
    return BT::NodeStatus::SUCCESS; // Not a failure, just can't process
  }

  // 3. Path Validation: Check if the path has been replanned
  if (isPathUpdated(path)) {
    RCLCPP_INFO(logger_, "New path detected. Re-initializing waypoint-to-path index map.");
    last_progress_index_ = 0;
    // Use the original full list of goals for mapping
    createWaypointIndexMapping(path, initial_goals_);
  }

  // 4. Get current robot pose
  geometry_msgs::msg::PoseStamped robot_pose;
  if (!updateRobotPose(robot_pose)) {
    return BT::NodeStatus::FAILURE;
  }
  
  // 5. Find robot's progress along the path using the search window
  size_t current_progress_index = findCurrentProgressIndex(path, robot_pose);
  last_progress_index_ = current_progress_index; // Update anchor for next tick

  // 6. Max Path Deviation Check
  double deviation = euclidean_distance(
    robot_pose.pose, path.poses[current_progress_index].pose);
  if (deviation > max_path_deviation_) {
    RCLCPP_WARN(
      logger_, "Robot deviated from path by %.2f m (max: %.2f m). Returning FAILURE.",
      deviation, max_path_deviation_);
    return BT::NodeStatus::FAILURE;
  }

  // 7. Main goal removal logic
  size_t initial_goals_passed = initial_goals_.size() - current_goals.size();
  while (!current_goals.empty()) {
      size_t current_goal_original_index = initial_goals_passed;

      if (waypoint_to_path_index_map_.find(current_goal_original_index) == waypoint_to_path_index_map_.end()) {
          RCLCPP_WARN(logger_, "Could not find mapping for goal index %zu. Stopping check.", current_goal_original_index);
          break;
      }
      
      size_t target_path_index = waypoint_to_path_index_map_.at(current_goal_original_index);
      
      // Hysteresis Check
      if (current_progress_index > target_path_index + hysteresis_indices_) {
          RCLCPP_INFO(logger_, "Goal %zu passed. Progress index %zu > target index %zu + hysteresis %u.",
              current_goal_original_index, current_progress_index, target_path_index, hysteresis_indices_);
          current_goals.erase(current_goals.begin());
          initial_goals_passed++;
      } else {
          // If the first goal isn't passed, none of the subsequent ones can be.
          break;
      }
  }

  // 8. Set output and return success
  setOutput("output_goals", current_goals);
  return BT::NodeStatus::SUCCESS;
}

bool AdvancedRemovePassedGoals::updateRobotPose(geometry_msgs::msg::PoseStamped & robot_pose)
{
  if (!nav2_util::getCurrentPose(
      robot_pose, *tf_, global_frame_, robot_base_frame_, transform_tolerance_))
  {
    RCLCPP_WARN(logger_, "Failed to get robot pose in %s frame.", global_frame_.c_str());
    return false;
  }
  return true;
}

bool AdvancedRemovePassedGoals::isPathUpdated(const nav_msgs::msg::Path & path)
{
  // Hash the path to get a unique identifier
  std::string path_str;
  path_str.reserve(path.poses.size() * 50); // Pre-allocate for efficiency
  for (const auto & pose : path.poses) {
    path_str += std::to_string(pose.pose.position.x) +
                std::to_string(pose.pose.position.y) +
                std::to_string(pose.pose.orientation.z) +
                std::to_string(pose.pose.orientation.w);
  }
  
  size_t new_hash = std::hash<std::string>{}(path_str);
  if (new_hash != last_path_hash_) {
    last_path_hash_ = new_hash;
    return true;
  }
  return false;
}

void AdvancedRemovePassedGoals::createWaypointIndexMapping(
  const nav_msgs::msg::Path & path,
  const std::vector<geometry_msgs::msg::PoseStamped> & goals)
{
  waypoint_to_path_index_map_.clear();
  if (path.poses.empty() || goals.empty()) {
    return;
  }

  for (size_t i = 0; i < goals.size(); ++i) {
    double min_dist_sq = std::numeric_limits<double>::max();
    size_t best_index = 0;
    for (size_t j = 0; j < path.poses.size(); ++j) {
      double dist_sq = nav2_util::geometry_utils::euclidean_distance_sq(
        goals[i].pose, path.poses[j].pose);
      if (dist_sq < min_dist_sq) {
        min_dist_sq = dist_sq;
        best_index = j;
      }
    }
    waypoint_to_path_index_map_[i] = best_index;
    RCLCPP_DEBUG(logger_, "Mapped goal %zu to path index %zu", i, best_index);
  }
}

size_t AdvancedRemovePassedGoals::findCurrentProgressIndex(
  const nav_msgs::msg::Path & path,
  const geometry_msgs::msg::PoseStamped & robot_pose)
{
  // 1. Determine search window boundaries based on physical distance
  size_t lower_bound = last_progress_index_;
  double cumulative_dist = 0.0;
  for (size_t i = last_progress_index_; i > 0; --i) {
    cumulative_dist += euclidean_distance(path.poses[i].pose, path.poses[i-1].pose);
    if (cumulative_dist > search_radius_) {
      break;
    }
    lower_bound = i - 1;
  }

  size_t upper_bound = last_progress_index_;
  cumulative_dist = 0.0;
  for (size_t i = last_progress_index_; i < path.poses.size() - 1; ++i) {
    cumulative_dist += euclidean_distance(path.poses[i].pose, path.poses[i+1].pose);
    if (cumulative_dist > search_radius_) {
      break;
    }
    upper_bound = i + 1;
  }

  // 2. Find the closest point within the determined window
  double min_dist_sq = std::numeric_limits<double>::max();
  size_t best_index = lower_bound;

  for (size_t i = lower_bound; i <= upper_bound; ++i) {
    double dist_sq = nav2_util::geometry_utils::euclidean_distance_sq(
      robot_pose.pose, path.poses[i].pose);
    if (dist_sq < min_dist_sq) {
      min_dist_sq = dist_sq;
      best_index = i;
    }
  }
  
  return best_index;
}

}  // namespace robust_nav2_bt_nodes


// This is the Behavior Tree plugin registration.
// You must in your CMakeLists.txt link this library to BehaviorTreeFactory
#include "behaviortree_cpp/bt_factory.h"
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<robust_nav2_bt_nodes::AdvancedRemovePassedGoals>("AdvancedRemovePassedGoals");
}
```
